package com.ecpss.test.jvm;

/**
 * Created by xc on 2019/7/20.
 */
public class jvmTest {
    
    /**
     * 字节码
     * 先压栈再到局部变量表汇中
     *
     Code:
     0: iconst_1  将int型1推送至栈顶 --操作数栈
     1: istore_1  将栈顶int型数值存入第本局部变量 表 int  a=12 存入到局部变量表
     2: iconst_1  int型1推送至栈顶 --操作数栈
     3: istore_2 将栈顶int类型值保存到局部变量2中。
     4: iload_1  第一个变量表推送至栈顶
     5: iload_2 第2个变量表推送至栈顶
     6: iadd  相加
     7: istore_3 将栈顶int类型值保存到局部变量3中。
     8: iload_3 第3个变量表推送至栈顶
     9: ireturn 返回
     
     */
    
    public int  aa(){
        int a=1;
        int b=12;
        int c=a+b;
        return c;
    }
    
    /**
     * 局部变量表
     存放的是编译时期的各种基本数据类型（byte、boolean、char、short、int、float、long、double）
     以及对象的引用（包括指向对象地址的引用指针或者是代表对象的句柄或者是相应的位置）和returnAddress类型（
     指向一条字节码指令的地址：函数返回地址）
     局部变量表所需的内存空间在编译期间完成分配
     * @param args
     */
    /**
     * 操作数栈
     操作数栈　遵循FIFO的原则。在操作数栈刚建立的时候为空的，
     只有在执行方法的时候才用于存放从局部变量表或者是全局常量等地方复制过来的数据，
     
     及生成的结果。操作数栈在存放的时候。long、double占用2个变量空间（Slot），其他占用一个。
     由于局部变量表的内存空间在编译期间已完成，所以在进入一个方法的时候，
     在操作数栈所要分配的内存空间已经完全确定，且在方法运行期间不会再发生变化
     * @param args
     */
    
    /**
     * 动态链接方法出口
     每一个栈中都包含一个指向运行时常量池中的引用。常量池中存在大量的符号参数，字节码的调用就以调用常量池中
     指向方法的符号 引用为参数，比如在类加载或者是第一次使用的时候转化为直接引用，（final、static），还有就是在运行期间转化
     当一个方法通过执行后，可能会有2种情况推出，执行引擎遇到返回指令或者是遇到异常，并且异常未在方法内处理。
     不管哪种情况，一旦方法返回，肯定要获得返回的地址，来保证正常的执行。而且在返回时可能会保存一些信息，来完成上层的处理。
     正常推出时，会将程序计数器来作为返回的地址；出现异常时则会通过异常处理器来确定
     * @param args
     */
    public static void main(String[] args) {
//        https://www.jianshu.com/p/0cd8322a116b
        
        new jvmTest().aa();
    }
    /**
     * 虚拟机规范还定义了在该区域的2个异常：
 
     当线程请求的栈深度大于虚拟机所允许的时候，会抛出StackOverFlowError异常
     当虚拟机栈动态扩容的时候，如果无法申请到足够的内存（申请的内存可能已经超过实际的内存），会抛出OutOfMemoryError异常
     */
}
