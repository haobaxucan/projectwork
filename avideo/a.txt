微信扫码支付
 功能
  首页视频列表
  视频详情
  微信扫码登录
  下单支付

 后台数据库设计
 -------------
 动静分离 nginx上存放静态资源
 负载均衡 a节点并发量很多，就去请求b节点
 -------------
 需求分析

----------------
数据库：画图er
数据库三大范式通俗解释 ----https://blog.csdn.net/q957967519/article/details/81910547
一范式就是属性不可分割。属性是什么？就是表中的字段。
二范式就是要有主键，要求其他字段都依赖于主键。
三范式就是要消除传递依赖，方便理解，可以看做是“消除冗余”

mysql 浮点数类型：FLOAT、DOUBLE

深度分页--where id>1000 limit 0,3   前面有个条件过滤
物理分页依赖的是某一物理实体，这个物理实体就是数据库，
比如MySQL数据库提供了limit关键字，程序员只需要编写带有limit关键字的SQL语句，
数据库返回的就是分页结果。

逻辑分页依赖的是程序员编写的代码。数据库返回的不是分页结果，而是全部数据，然后再由程序员通过代码获取分页数据，
常用的操作是一次性从数据库中查询出全部数据并存储到List集合中，因为List集合有序，再根据索引获取指定范围的数据。
https://blog.csdn.net/u012505684/article/details/82083074
-------------------------------
1 分布式应用下登录校验，session共享，分布式缓存使用 使用redis集中管理session，
可以将用户的会话保存在redis中，每次从redis中查询用户信息，就可以很好的解决会话共享问题。
2 JSON Web Token(JWT)是目前最流行的跨域身份验证解决方案。

客户端接收服务器返回的JWT，将其存储在Cookie或localStorage中。
此后，客户端将在与服务器交互中都会带JWT。如果将它存储在Cookie中，
就可以自动发送，但是不会跨域，因此一般是将它放入HTTP请求的Header Authorization字段中。
Authorization: Bearer
当跨域时，也可以将JWT被放置于POST请求的数据主体中。
放在cookie解决session共享问题
Cookie cookie = new Cookie("token", token);
             cookie.setMaxAge(3600);
             cookie.setDomain("localhost");
             cookie.setPath("/");
             response.addCookie(cookie);
-------------------------------------------
jwt
JWT的三个部分如下。JWT头、有效载荷和签名

头部：主要是描述签名算法
负载：主要描述是加密对象的信息，如用户的id等，也可以加些规范里面的东西，如iss签发者，exp 过期时间，sub 面向的用户
签名：主要是把前面两部分进行加密，防止别人拿到token进行base解密后篡改token
放在拦截器posthandler 实在prehandler 为true 的时候执行
-----------------------------------------------------
第三方登录（微信）
https://open.weixin.qq.com/
内网穿透工具
https://blog.csdn.net/qq_33404395/article/details/80788233
----------------
扫描登录时序图角色理解0---
微信用户--我
第三方应用比如百度云盘
微信开放平台
------------
快捷键
ctrl+alt+h的功能的英文名意思是"调用层次"，alt+f7的功能的英文名意思是"找到使用的地方"。

-------------------
在UML系统开发中有三个主要的模型：（UML-Unified Modeling Language 统一建模语言）
功能模型
从用户的角度展示系统的功能，包括用例图。
对象模型
采用对象、属性、操作、关联等概念展示系统的结构和基础，包括类图、对象图、包图。
动态模型
展现系统的内部行为。 包括序列图、活动图、状态图。
--------------------------------------------------------Sequence Diagram
系统角色，可以是人或者其他系统，子系统。以一个小人图标表示。
对象：时序图中的对象在交互中扮演的角色就是对象，使用矩形将对象名称包含起来, 名称下有下划线

			生命线：生命线是一条垂直的虚线, 这条虚线表示对象的存在, 在时序图中, 每个对象都有生命线

			激活：代表时序图中对象执行一项操作的时期, 表示该对象被占用以完成某个任务，当对象处于激活时期, 生命线可以拓宽为矩形

			消息：对象之间的交互是通过相互发消息来实现的，箭头上面标出消息名，一个对象可以请求（要求）另一个对象做某件事件
			消息从源对象指向目标对象，消息一旦发送便将控制从源对象转移到目标对象，息的阅读顺序是严格自上而下的

			消息交互中的实线：请求消息  （request）
			消息交互中的虚线：响应返回消息  （返回请求的消息）

			自己调用自己的方法：反身消息 某一个类调用自己的方法
------------------------------------------
pay.png--看
业务流程说明：

（1）商户后台系统根据用户选购的商品生成订单。

（2）用户确认支付后调用微信支付【统一下单API】生成预支付交易； //意思是请求微信的api

（3）微信支付系统收到请求后生成预支付交易单，并返回交易会话的二维码链接code_url。

（4）商户后台系统根据返回的code_url生成二维码。

（5）用户打开微信“扫一扫”扫描二维码，微信客户端将扫码内容发送到微信支付系统。

（6）微信支付系统收到客户端请求，验证链接有效性后发起用户支付，要求用户授权。

（7）用户在微信客户端输入密码，确认支付后，微信客户端提交授权。

（8）微信支付系统根据用户授权完成支付交易。

（9）微信支付系统完成支付交易后给微信客户端返回交易结果，并将交易结果通过短信、微信消息提示用户。微信客户端展示支付交易结果页面。

（10）微信支付系统通过发送异步消息通知商户后台系统支付结果。商户后台系统需回复接收情况，通知微信后台系统不再发送该单的支付通知。

（11）未收到支付通知的情况，商户后台系统调用【查询订单API】。
宕机了----//执行定时任务 --微信付款成功，但是订单状态没有改变，所以定时调用查询api --有，更改商户状态

（12）商户确认订单已支付后给用户发货。


----------------------------
测试：选中接口-右键--go to --test ---test包里面生成--添加如下注解
@RunWith(SpringRunner.class)
@SpringBootTest
---------------
事务 的传播机制
PROPAGATION_REQUIRED    如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择（有事务用老的）

PROPAGATION_REQUIRES_NEW  新建事务，如果当前存在事务，把当前事务挂起。（用新的事务）
PROPAGATION_SUPPORTS   支持当前事务，如果当前没有事务，就以非事务方式执行。